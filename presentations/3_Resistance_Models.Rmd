---
title: "Resistance Models"
author: "Landscape Genetic Data Analysis"
date: "Scotland, October 2016"
output: html_document
---

![](../media/ch_mountain.jpg)

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
library(ggplot2)
theme_set( theme_bw() )
```

## Synopsis

One of the characteristics of landscape genetics studies, maybe even a defining feature, is its use of resistance and distance approaches to understanding the spatial distribution of genetic structure and *hopefully* to use it in support of characterizing landscape mediated connectivity.  In this activity, we will explore how to characterize and estimate separation and delve into a approaches for understanding how we can analyze similarily defined genetic distances.

## Objectives


1. Explore two different methods for estimating separation on raster serfaces, least cost and all-paths.
2. Analyze distance matrices using correlative, regression, and eigenvalue based approaches.



## Data For Resistance Modeling

Due to the structuring in the data shown above, we will be using a subset of the populations from the *arapat* dataset designed as `Species==Peninsula`.  I'll also restict them to the ones in the norther part of the peninsula.  The estimation of cost distance is a computationally intensive process and it is not in our best interests to be working on huge data sets in a workshop using just our laptops!

```{r}
library(gstudio)
data(arapat)
arapat <- arapat[ arapat$Species == "Peninsula",]
t <- table( arapat$Population )
keepers <- names( t[ t>9] )
keepers <- keepers[ keepers != "165"]
arapat <- arapat[ arapat$Population %in% keepers, ]
arapat <- droplevels( arapat )
table(arapat$Population)
```

We will also be using the same landscape rasters that we manipulated in the first afternoon.  In the examples below, I'll use `alt` to demonstrate the concepts and then we can go back at the end and explore some of the other features from the rasters you have already manipulated.

```{r}
library(rgeos) 
require( raster )
Temp <- raster("./LGDA-Data/bioclim/bio5_22.tif")
pts <- strata_coordinates( arapat, as.SpatialPoints = TRUE)
hull <- gConvexHull(pts)
hull_plus_buffer <- gBuffer(hull,width=.2)
Temp <- trim( mask( Temp, hull_plus_buffer))
plot( Temp )
plot( pts, add=TRUE )
```


## Determining Resistance

> The resistance value that best explains the spatial connectivity of our genetic data is more likely to be representitive of the resistance that the organism actually encounters.

Resistance is a moniker that is used commonly in landscape genetic studies.  It connotates a friction, based upon features of the landscape itself, that influences the movement of either individuals or genetic materials.  While population genetics has traditionally been focused on isolation caused by Euclidean separation, there is no reason why other metrics cannot be incorporated and in fact, the methods that have been developed for euclidean easily extended to non-spatial approaches.

The way in which the intervening habitat may influence genetic connectivity can be both varied and complex.  In R, we quantify spatial data using a `raster` format.  Independent of where you get the rasters, you will most likely need to modify them to create a the input for biologically meaningful hypotheses. Several approaches are available to parameterizing a cost surface and they will depend upon your organism, the features you are testing, and the spatial extent to which you are analyzing.  There are two basic categories of resistance to consider; absolute and relative.

### Absolute Resistance

Absolute resistance denotes a constant value for resistance across a landscape independent of the location or source.  In the example below, I use maximum temperature as the feature onto which we can assign resistance values for our organism. If we look at the distribution of slope values we can see the vast majority of the lower part of Baja California has a rather gentle slope.  

```{r distribution-of-slope, fig.cap="Distribution of estimates for temperature (in degrees C) across all pixels in the altitude raster."}
df <- data.frame( rasterToPoints(Temp))
names(df)[3] <- "MaxTemp"
df$MaxTemp <- df$MaxTemp / 10 
ggplot( df, aes(x=MaxTemp)) + geom_histogram( binwidth=0.5) + 
  xlab("Maximum Temperature (C)") + ylab("Frequency")
```

```{block, note-slope-scale, type='comment_information'}
It is very important to note that the slope we are deriving here is based upon an average across a 30-arc second pixel size in the desert.  We are perhaps missing a lot of sub-kilometer variagion in temperature areas that prevent movement.  However, this is an example meant more for the importance of providing the methodology of how you would do this than an expectation explaining biological relevance.
```

How your organism interact with something like slope is the key point, and in fact the thing we are often trying to figure out.  For this example, the resistance will be categorical, with three levels of resistance (again, this is an example and a bit arbitrary):  

- Temp < 5$^{\circ}$ has no effect on movement.
- Slope at a location between 5$^{\circ}$ and 10$^{\circ}$ result in a movement resistance twice as difficult as the low/no slope condition.
- Slope in excess of 10$^{\circ}$ is categorized as four times as difficult for movement than the low/no slope areas on the map.

```{r}
tmp <- E
tmp[ E <= 330 ] <- 1
tmp[ E > 330 ] <- 2
tmp[ E > 360 ] <- 4
temp.cats <- ratify(tmp, count=TRUE)
rat <- levels( temp.cats )[[1]]
rat$Slope_Type <- c("OK","HOT","BURNING")
levels(temp.cats) <- rat 
temp.cats
```

The categories are defined by the *raster attribute table* (see `?ratify`). 

```{r}
df <- data.frame( rasterToPoints(temp.cats) )
names(df) <- c("Longitude","Latitude","MaxTemp")
df$MaxTemp <- factor( df$MaxTemp )
p <- ggplot( df, aes(Longitude,Latitude,fill=MaxTemp)) + geom_tile() 
p + scale_fill_brewer(type="qual",palette=3) 
```


### Relative Resistance

The other way in which rasters may be created are are based upon relative cost distances.  These cost surfaces are created, relative to some particular benchmark point on the surface.  For example, if you think that phenology (e.g., the timing of reproduction) may be an important component contributing to connectivity among populations (as is the case for plant species), it is not the absolute value of elevation that is of concern across the landscape.  Rather it is the similarity in elevation that is the driver---plant populations at the same elevations tend to flower in higher synchrony than those separated across elevation gradients.  As such, when we estimate cost surfaces for something like this, we would focus on on the magnitude of elevation but on the absolute difference in elevation between points.  Under this *relative* cost approach, the distance from each locale would be based upon the deviance in elevation from that point to the rest of the landscape.  

I'll use this concept of elevation similarity in this example, starting with the elevation of population `175`, which will be the benchmark.

```{r}
idx <- which( rownames( coordinates(pts) ) == "171")
target <- extract( Temp, pts[idx] )
target
```

From this target temperature, we can create a raster that is based upon the deviation between the benchmark and everyone else.  

```{r}
temp_similarity <- abs( Temp - target )
plot(temp_similarity)
plot( pts[idx], add=TRUE)
```

The values of this raster will now need to be examined to make decisions about how resistence will be encoded.

```{r}
vals <- values( temp_similarity )
df <- data.frame( Delta=vals[ !is.na(vals) ] )
ggplot( df, aes(x=Delta)) + geom_histogram(bins=50)
```


### Ranges of Resistance

In describing relative and absolute resistances, I made three simplifying assumptions. First I selected the magnitude of values somewhat arbitrarily when I used 2x and 4x increase in resistance for slope.  I also defined the cutoff regions as specific values. Finally, I assumed a functional form, in the first with 3 categories and in the second with assuming the absolute value in elevation differences would be biologically meaningful.  In reality, it is better if we make these decisions with some kind of biological motivation.  However, if we do not have existing data, we can estimate the magnitude of relative resistance as a part of the analysis as well.

One common approah is to examine a range of magnitudes in resistance, say 2x, 5x, 10x, & 50x and then let the subsequent analyses figure out which is best at describing the distribution of genetic variation.  To do this, we can create a dichotomous raster indicating presence (1) and absence (0) of the feature in question.  For simplicity, I'll use the slope with a cutoff of 5 degrees to designate the two resistance regions.

```{r}
temp_bin <- Temp
temp_bin[ Temp < 350] <- 0
temp_bin[ Temp  >= 350] <- 1
plot(temp_bin)
```

From this, we can create a set of alternative resistance values, all based upon the same binary raster. 

```{r}
temp.2 <- temp_bin + 1
temp.5 <- temp_bin*4 + 1
temp.10 <- temp_bin*9 + 1
temp.50 <- temp_bin*49 + 1 
temps <- stack( temp.2, temp.5, temp.10, temp.50)
temps
```


### Raster Resolution







## Estimating Separation

Once we have defined one or more rasters quantifying resistance costs, we can go and estimate the distance among points on those rasters.  There are several ways available for us to estimate distance.  The differences in these methods are based upon the algorithm used to estimate separation and the extent of the raster used to apply these algorithms.

### Least Cost Distance

A least cost path is the route between two points, say $A \to B$, whose measured cost is minimal.  This is the *optimal* route across the landscape.  Organisms or vectors of gene exchange may, or may not, move across a landscape following an *optimal* path.  An example shortest path is shown in Figure \@ref(fig:lcp-example).

```{r lcp-example, echo=FALSE, fig.cap="Estimation algorithm for least-cost path distance.  The path chosen is the one with the shortest overall distance, or at least one of the paths with equally short overall distances."}
knitr::include_graphics("../media/LCP.png")
```

One way to estimate distances in R, is through the use of the `gdistance` library.  In this approach, we define a transition object based upon:  
1. The cost distance raster.  By default, the `transition()` function works on conductance, which is the inverse of resistance.  In these examples, we have used a single raster, though use of *RasterBrick* objects is just as appropriate.
2. The function by which we estimate the pixel-to-pixel distances.  
3. The neighborhood around each pixel that we look at during each step.  Options for this include:  
  - A von Neumann neighborhood (`directions=4`) consists of the pixels immediately above, below, and on both sides of the target pixel.  
  - A Moore's neighborhood (`directions=8`) consisting of all pixels surrounding the target pixel (e.g., even the diagonal ones)
  - A Knight & One-Cell Queen move (`directions=16`), which adds the next layer of cells outside of Moore's neighborhood.

Once estimated, the transition object *must* be corrected for if you are either using a large extent based upon Latitude and Longitude datum (e.g., they are not unit-wise consistent in area), or you have used a `direction` option other than the von Neuman Neighborhood.

In the example below, I use the cost distance estimated as an absolute distance with a resistance cost of 2:1.

```{r message=FALSE, warning=FALSE}
library(gdistance)
tr <- transition( 1/temp.10, transitionFunction = mean, directions = 4 )
tr <- geoCorrection( tr, type="c", multpl=FALSE, scl=FALSE)
tr
```

From this, potentially corrected, transition object we can estimate shortest path distance using the aptly named function `shortestPath()`, passing it the transition object, the point from which we are starting, and the destination, and an optional parameter on how we want the output returned.  In the example below, the results is returned as a *SpatialLines* object which I use to plot.

```{r}
path.1 <- shortestPath( tr, pts[4], pts[13], output="SpatialLines")
plot( temp.10 , xlab="Longitude", ylab="Latitude")
lines( path.1, col="red")
points( pts[c(4,13)],pch=16, col="red")
```

To estimate the length of the shortest paths using `costDistance()` and return it as a matrix (it is a sparse matrix)

```{r}
D.absolute <- as.matrix( costDistance(tr, pts) )
D.absolute[1:10,1:10]
```

Least cost, on a relative resistance map, is a bit more complicated as we have to measure the `costDistance()` from the perspective of each of the $K$ stratum.  This is going to take a bit of programming but it isn't too hard.  Essentially, we must:  
1. Select a target population.
2. Make a relative cost distance raster.
3. Estimate the `costDistance()` between the target population and all remaining ones.
4. Select next target population and continue until you run out of populations.

The code below takes a while to run.  It will print out progress as it goes to let you know it is doing something.

```{r}
# define function that takes a raster, some points, and your
#   maximum resistance and it iterates through the stratum 
#   and returns the relative distance matrix.
relative_dist <- function( the_raster, pts, max_resistance){
  library(sp)
  library(reshape2)
  sites <- rownames(coordinates(pts))  # find site names
  K <- length( sites )                    # how many site
  
  ret <- data.frame( From=rep(sites, each=K), # make data.frame
                     To=rep( sites, times=K), # for results
                     Distance=NA )
  
  # Set sites as factors so matrix has the right order
  ret$From <- factor( ret$From, ordered=TRUE, levels=sites)
  ret$To <- factor( ret$To, ordered=TRUE, levels=sites)
  ret <- ret[ (ret$From != ret$To), ]
  
  # iterate through the site & do what we did above.
  cat("Estimating relative distance from", length(sites), "sites: ")
  for( i in 1:K){
    cat(".")
      
    target_elevation <- extract( the_raster, pts[i] )
    base_map <- abs( the_raster - target_elevation )
    base_map <- base_map / maxValue(base_map) * max_resistance
    tr <- transition( 1/base_map, transitionFunction = mean, directions = 4)
    tr <- geoCorrection( tr, type="c", multpl=FALSE, scl=FALSE)
    d <- costDistance(tr,pts[i], pts[-i])
    from_pop <- rep( sites[i], length(d))
    ret$Distance[ ret$From==from_pop ] <- as.numeric( d )
  }
  cat("[done]\n")
  # turn results data.frame into matrix
  ret <- dcast( ret, From~To, value.var="Distance", fill=0)
  return( as.matrix( ret[, 2:ncol(ret)]) )
}
```

This process can take a bit of time.  On my laptop it takes about 4 second per site (there are 13 sites). 

```{r eval=FALSE}
D.relative <- relative_dist( E, pts, max_resistance = 10)
save( D.relative, file="../media/D.relative.rda")
```

```{r echo=FALSE}
load("../media/D.relative.rda")
```


To get an idea of how the two different approaches deviate in estimation of distances, here is a plot of the two. 

```{r}
df <- data.frame( Absolute=as.numeric( D.absolute ),
                  Relative=as.numeric(D.relative))
df <- df[ !is.infinite(df$Absolute),]
ggplot( df, aes(Absolute, Relative)) + geom_point() + 
  xlab("Absolute Absolute") + ylab("Relative Resistance")
```


### All Paths (Circuit) Distance

Organisms may not move in an *optimal* way across the landscape but may move along several different paths, most of which are *unoptimal*.  The relative proportion of these alternative paths and their lengths may be combined to produce a distance between sites based upon all potential paths, $A \Rightarrow B$.  In the context of genetic connectivity, this method is referred to by the name of one of the software packages available to estimate it, [Circuitscape](http://circuitscape.org) by McRae (2006). 

You can also estiamte circuit distance using the *gdistance* library as we did for least cost path.  The change that you need to make is in the `geoCorrection` component, make it 'r' instead of 'c'.

```{r eval=FALSE}
tr <- transition( 1/temp.10, transitionFunction = mean, directions = 4 )
tr <- geoCorrection( tr, type="r", multpl=TRUE)
D.circuit <- commuteDistance( tr, pts )
```
<pre>
Error in LU.dgC(a) : cs_lu(A) failed: near-singular A (or out of memory)
</pre>
Which you can see causes a problem.  This is not always an issue but it does arrise on occasion.  The cause of this problem is that we must estiamte a distance network between each pixel in the raster.  Then we must estimate the lengths of all paths across that raster, which depending upon how you do it, may have some issues.  The current developer of the igraph libary, where `commuteDistance` goes for this estimator has said

![](../media/gabor.png)

Fortunatley for us, there is another option.  Circuitscape, a stand alone Java application can be used to estimate distances and you should have downloaded it and have it on your computer.  What we need as input is a raster and our points.

Both raster and point data should be converted into *.asc raster format.  

```{r, eval=FALSE}
cost <- temp.10
sites <- rasterize(x = pts,y = cost)
writeRaster(sites,"sites_rast.asc",overwrite=TRUE)
writeRaster(cost,"cost_rast.asc",overwrite=TRUE)
```

Then start Circuitscape and set the following parameters:  
1. Choose Step 1: Raster
2. Choose Step 2: All pairs
3. Use the file section buttons to load in both the cost and site rasters.
4. Select an output location (it will create a lot of files)
5. Selection the option to save a current map.
6. Hit Run.

It will take a bit of time, it has to estiamte all pairs of points.  In this case, with $K=16$, that is 120 distances.

When it finishes, it will produce a lot of files, two of which we are interested in working with.  The separation data is in a file called  "trees_resistances_3columns".  If you named the output something other than 'tree' (as I did ), it will be prefixed with that name instead. We can load that into R and make it into a matrix.

```{r warning=FALSE, message=FALSE}
data <- read.table("trees_resistances_3columns",header=FALSE, sep=" ")
CT <- matrix(0,nrow=ncol(D.relative),ncol=ncol(D.relative))
for( i in 1:nrow(data)){
  CT[ data$V1[i], data$V2[i] ] <- data$V3[i]
}
CT <- CT + t(CT)
rownames(CT) <- colnames(CT) <- rownames(D.absolute)
CT[1:10,1:10]
```

Now we can examine the differences by plotting them.  I have to remove the 0 values first, no need to plot the distance from sites to themselves...

```{r}
df <- data.frame( Circuit=as.numeric(CT),
                  LCP=as.numeric( D.relative) )
df <- df[ df$Circuit != 0, ]
ggplot( df, aes(x=Circuit, y=LCP)) + geom_point()
```

So both are giving us a similar kind of data, however which does a better job of describing genetic structure?



## Analyzing Genetic & Raster Distances

So here it is!  Finally, three days into the ordeal and we can now begin to actually analyze some of the data in a way that is characteristically "landscape genetic" !

### Mantel Tests

By far, the most commonly used method to ascertain similarities in distance matrices is that of the Mantel test.  The Mantel test is simply a measure of correspondence between matrices.  It estimates a parameter, $Z$, as the element-wise product of both matrices.

\[
Z = \sum_{i=1}^N\sum_{j=1}^N x_{ij}*y_{ij}
\]

and then invokes the null hypothesis, $H_O:$*The values in the matrices are independent*.  If this is true then large values in $\mathbf{X}$ should be randomly associated with all the values in $\mathbf{Y}$.  However, if there is an assocaition than large values in one matrix may be associated with large ones in the other (for a positive correlation) or small in one may be associated with large in another (for a negative correlation).  If $H_O$ is true, then any permutation of $\mathbf{X}$ and a reestimation of $Z$ should produce values as large (or small) as the observed $Z$ value.  Sounds simple, no?

Fortunately, there is an easier way to perform the Mantel, provided by the library *vegan*.  For their implentation, we need `dist` objects instead of matrices.

```{r}
library(vegan)
E.LCP.abs <- as.dist( D.absolute )
E.LCP.rel <- as.dist( D.relative )
E.CT <- as.dist( CT )
P <- as.dist( P )
G <- as.dist( D.nei )
```

We can then fit the hypothesis matrices to the genetic distance.

```{r}
fit.1 <- mantel( G, E.LCP.abs )
fit.2 <- mantel( G, E.LCP.rel )
fit.3 <- mantel( G, E.CT )
fit.4 <- mantel( G, P )
df <- data.frame( Model=c("LCP Absolute","LCP Relative","Circuit","Euclidean"))
df$rho <- c( fit.1$statistic,
             fit.2$statistic,
             fit.3$statistic,
             fit.4$statistic )
df$P <- c( fit.1$signif,
           fit.2$signif,
           fit.3$signif,
           fit.4$signif
           )
knitr::kable( df )
```




```{r eval=FALSE}
mantel.partial(as.dist(D),as.dist(C),as.dist(P))
mantel.partial(as.dist(D),as.dist(P),as.dist(C))

```



```{r}
library(raster)
library(sp)
pts <- strata_coordinates(data,as.SpatialPoints = TRUE)
alt <- raster("../spatial_data/alt.tif")
pts$elev <- extract(alt, pts)
pts <- pts[ !is.na(pts$elev),]
coords <- coords[ !is.na(pts$elev),]
P <- strata_distance(coords)
elev <- outer(pts$elev, pts$elev, function(x,y) return ( (x - y)^2 ))
lat <- outer( coords$Latitutde, coords$Latitude, function(x,y) return ( (x - y)^2 ))

df1 <- data.frame( Latitude= coordinates(pts)[,2], Elevation=pts$elev)
ggplot( df1, aes(Latitude, Elevation)) + geom_point() + theme_bw()
cor(df1$Latitude, df1$Elevation )
```

```{r}
elev <- outer(df1[,2], df1[,2], function(x,y) return ( (x - y)^2 ))
lat <- outer( df1[,1], df1[,1], function(x,y) return ( (x - y)^2 ))
df2 <- data.frame( Elevation = elev[ lower.tri(elev)], Latitude= lat[ lower.tri(lat)] )
ggplot( df2, aes(Latitude, Elevation)) + geom_point() + theme_bw() + xlab("Pairwise Latitude") + ylab("Pairwise Elevation")
cor( df2$Latitude, df2$Elevation )
```


### Autocorrealtion problem with mantel


```{r}
X <- rnorm(1296)
Y <- rnorm(1296)

rX <- raster(matrix(X,nrow=36))
rY <- raster(matrix(Y,nrow=36))

plot(rX,legend=FALSE,axes=FALSE, box=FALSE)
plot(rY,legend=FALSE,axes=FALSE, box=FALSE)
rho.p <- rep(NA,10000)
fit <- cor.test(X,Y)
K <- 50

for( i in 1:10000){
  idx <- sample( 1:2500, size=K, replace=FALSE)
  ct <- cor.test(X[idx], Y[idx])
  rho[i] <- ct$p.value
}
type1 <- length(rho[ rho<0.05])/1000
type1
```



```{r}
xr <- raster(ncols=50, nrows=50, xmn=0)
xr[] <- runif(ncell(xr))
sX <- focal(xr, w=matrix(1/2,nrow=15,ncol=15))

plot(sX, legend=FALSE,axes=FALSE, box=FALSE)

yr <- raster(ncols=50, nrows=50, xmn=0)
yr[] <- runif(ncell(yr))
sY <- focal(yr, w=matrix(1/9,nrow=15,ncol=15))
plot(sY, legend=FALSE,axes=FALSE, box=FALSE)

vX <- values(sX)
vY <- values(sY)
vXp <- vX[ !is.na(vX) & !is.na(vY)]
vYp <- vY[ !is.na(vX) & !is.na(vY)]

rho.sp <- rep(NA,10000)
for( i in 1:10000){
  idx <- sample( 1:2116, size=K, replace=FALSE)
  ct <- cor.test(vXp[idx], vYp[idx])
  rho.sp[i] <- ct$p.value
}
type1.sp <- length(rho.sp[ rho.sp<0.05])/1000
type1.sp
```


```{r}
par( mfrow=c(2,2) )
plot(rX,legend=FALSE)
plot(rY,legend=FALSE)
plot(sX, legend=FALSE)
plot(sY, legend=FALSE)
```





```{r}
D <- genetic_distance(data,mode="Nei")
coords <- strata_coordinates( data )
pts <- strata_coordinates(data,as.SpatialPoints = TRUE)
elev <- extract(alt, pts)
coords <- coords[ !is.na(elev),]
elev <- elev[ !is.na(elev)]
P <- strata_distance( coords )
w <- 1/P
diag(w) <- 0
ape::Moran.I(elev,w)

hist(w)
hist(elev)
qplot( elev, geom="histogram", bins=20) + xlab("Elevation") + theme_bw() + ylab("Frequency")
```


### Raster Autocorrelation

```{r}
alt <- raster("../spatial_data/alt.tif")
pts <- rbind( c(-111.5,27.0),
              c(-112.4,26.7),
              c(-111.7,25.7),
              c(-111.1,25.4),
              c(-110.8,26.0),
              c(-111.5,27.0) )
polys <- SpatialPolygons(list(Polygons(list(Polygon(pts)),"Polygon")))
loredo <- trim( mask( alt, polys ) )
plot(loredo, xlab="Longitude",ylab="Latitude")
```


```{r}
Moran(loredo)
```


```{r}
ml <- MoranLocal(loredo)
plot(ml, xlab="Longitude",ylab="Latitude")
```







## Questions
